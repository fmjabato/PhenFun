#! /usr/bin/env Rscript

#' @description 
#' @author Fernando Moreno Jabato <jabato(at)uma(dot)es>
#' @import optparse

##############################################################################
##                           CONFIGURE PROGRAM                              ##
##############################################################################

# Load necessary packages
suppressPackageStartupMessages(require(optparse))        # Parse script inputs

# Prepare input commands
option_list <- list(
  make_option(c("-i", "--input"), action="store",type="character",
              dest="input", help="Input SORs coordinates file. Structure must be <init>,<end>,<chr>,<sorID> separated by tabulators"),
  make_option(c("-f", "--filter"), action="store",type="character",
              dest="filter", help="Blacklist to be used as filter. Must store regions in same format than input SORs file but with optional <sorID>"),
  make_option(c("-o", "--output"), action="store",type="character",
              dest="output", help="Output file basename used for filtered SORs storage and extra data generated by the process"),
  make_option(c("-t", "--type"), action="store",type="character", default = "r",
              dest="type", help="Filtering type to be executed. Allowed: (r) remove SORs by any overlapping; (c) Cut SORs into if overlapping is partial. Default: %default"),
  make_option(c("-n", "--net"), action="store",type="character", default = NULL,
              dest="net", help="(OPTIONAL) Network with SORs IDs to be updated after filtering"),
  make_option(c("-O", "--netoutput"), action="store",type="character", default = NULL,
              dest="netoutput", help="(OPTIONAL) Output file where updated network will be stored. Default: overwrite input network file"),
  make_option(c("-v", "--verbose"), action="store_true",type="logical", default = FALSE,
              dest="verbose", help="Activate verbose mode")
)

opt <- parse_args(OptionParser(option_list=option_list))

##############################################################################
##                           LOAD SOURCE DATA                               ##
##############################################################################

########################################
## Verbose point
if(opt$verbose) message("Loading data")

# Prepare useful variables
col_structure <- c("start","end","chr")

# Load SORs
sors <- read.table(file = opt$input, sep = "\t", stringsAsFactors = FALSE)
sors <- sors[,1:4]
colnames(sors) <- c(col_structure,"id")

# Load blacklist
blacklist <- read.table(file = opt$filter, sep = "\t", stringsAsFactors = FALSE)

if(ncol(blacklist) == 3){
	blacklist <- blacklist[,1:3]
	colnames(blacklist) <- col_structure
	blacklist$id <- seq(nrow(blacklist))
}else{
	blacklist <- blacklist[,1:4]
	colnames(blacklist) <- c(col_structure,"id")
}

# Sort blacklist by chr and start to speed up at search
blacklist <- blacklist[order(blacklist$chr,blacklist$start),]

# Check filtering type
filter_remove <- opt$type == "r"
filter_cut    <- opt$type == "c"

# Load Network (if proceeds)
updateNet <- !is.null(opt$net)
if(updateNet){
	# Load
	net <- read.table(file = opt$net, sep = "\t", stringsAsFactors = FALSE)
	# Prepare output
	if(is.null(opt$netoutput)){
		opt$netoutput <- opt$net
	}
}


##############################################################################
##                           FIND OVERLAPPINGS                              ##
##############################################################################

########################################
## Verbose point
if(opt$verbose) message("Finding overlaps")

# Sort regions by chromosome
allowed_chrs <- unique(c(sors$chr,blacklist$chr))
blacklist_byChr <- lapply(allowed_chrs,function(chr){which(blacklist$chr == chr)})
names(blacklist_byChr) <- allowed_chrs

# Calculate all overlappings per SOR
overlappings <- as.data.frame(do.call(rbind,lapply(seq(nrow(sors)),function(i){
	# Check
	if(length(blacklist_byChr[[as.character(sors$chr[i])]]) <= 0){
		return(NULL)
	}
	# Take data
	A_start <- sors$start[i]
	A_end <- sors$end[i]
	# Compare against all blacklist regions
	regions_out_of_target <- FALSE
	curr_overlaps <- as.data.frame(do.call(rbind,lapply(blacklist_byChr[[as.character(sors$chr[i])]],function(j){
		# Check
		if(regions_out_of_target) return(NULL)
		# Init
		B_start <- blacklist$start[j]
		B_end <- blacklist$end[j]
		# Evaluate
		if(A_start <= B_start){
			if(A_end <= B_start){ # Null intersect AND next regions will not overlap because of (B_start_i <= B_start_i+1)
				regions_out_of_target <<- TRUE
				return(NULL)
			}else{ # Overlap 
				# Find overlap init
				O_start <- B_start
				# Find overlap end
				O_end <- ifelse(B_end <= A_end, B_end, A_end)
			}
		}else if(A_start > B_end){ # Null intersect
			return(NULL)
		}else{ # Overlap (A shifted to right)
			# Find overlap init
			O_start <- A_start
			# Find overlap end
			O_end <- ifelse(B_end <= A_end, B_end, A_end)
		}

		# Return overlapping
		return(data.frame(A = sors$id[i],
						  B = blacklist$id[j],
						  chr = sors$chr[i],
						  A_start = A_start,
						  A_end   = A_end,
						  B_start = B_start,
						  B_end   = B_end,
						  O_start = O_start,
						  O_end   = O_end))
	})))
	# End
	return(curr_overlaps)
})))

########################################
## Verbose point
if(opt$verbose) message("Collapsing overlaps")

# Collapse overlappings depending on filter type
final_ids <- unique(sors$id)
if(nrow(overlappings) > 0){
	overlap_collapsed <- as.data.frame(do.call(rbind,lapply(unique(overlappings$A), function(id){
		# Find
		indx <- which(overlappings$A == id)
		# Remove original fragment
		final_ids <<- setdiff(final_ids,id)

		# Check filter type
		if(filter_remove){
			return(data.frame(start = -1,
							  end   = -1,
							  chr   = overlappings$chr[indx[1]],
							  id    = id,
							  Source_start = overlappings$A_start[indx[1]],
							  Source_end = overlappings$A_end[indx[1]],
							  Source_SOR = overlappings$A[indx[1]],
							  Action = "REMOVED"))
		}
		if(filter_cut){
			# Sort blacklist fragments
			bl_frags <- overlappings[indx,]
			bl_frags <- bl_frags[order(bl_frags$O_start,bl_frags$O_end),]
			# Collapse overlapping blacklist fragments
			bl_frags_collapsed <- data.frame(start = numeric(0), end = numeric(0))
			curr_start <- bl_frags$O_start[1]
			curr_end <- bl_frags$O_end[1]
			invisible(lapply(tail(seq(nrow(bl_frags)),-1),function(i){
				# Check
				if(curr_end >= bl_frags$O_start[i]){ # Overlap
					curr_end <<- bl_frags$O_end[i]
				}else{# Store current fragment and update new
					bl_frags_collapsed <<- rbind(bl_frags_collapsed, data.frame(start = curr_start, end = curr_end))
					curr_start <<- bl_frags$O_start[i] 
					curr_end <<- bl_frags$O_end[i] 
				}
			}))
			bl_frags_collapsed <- rbind(bl_frags_collapsed, data.frame(start = curr_start, end = curr_end))
			# Initiate final fragments container
			new_frags <- data.frame(start = numeric(0),
									end   = numeric(0),
									chr   = character(0),
									id    = character(0),
									Source_start = numeric(0),
									Source_end = numeric(0),
									Source_SOR = character(0),
									Action = character(0))
			# Calculate final fragments
			curr_start <- bl_frags$A_start[1]
			frag_end <- bl_frags$A_end[1]
			invisible(lapply(seq(nrow(bl_frags_collapsed)),function(i){
				# Check cut type
				if(curr_start < bl_frags_collapsed$start[i]){ # There is a fragment at left
					new_frags <<- rbind(new_frags, data.frame(start = curr_start,
															 end   = bl_frags_collapsed$start[i],
															 chr   = bl_frags$chr[1],
															 id    = bl_frags$A[1],
															 Source_start = bl_frags$A_start[1] ,
															 Source_end = bl_frags$A_end[1],
															 Source_SOR = bl_frags$A[1],
															 Action = "FRAGMENTED"))
				}
				curr_start <<- bl_frags_collapsed$end[i]
			}))
			# Check stacked fragment
			if(curr_start < frag_end){
				new_frags <- rbind(new_frags, data.frame(start = curr_start,
														 end   = frag_end,
														 chr   = bl_frags$chr[1],
														 id    = bl_frags$A[1],
														 Source_start = bl_frags$A_start[1] ,
														 Source_end = bl_frags$A_end[1],
														 Source_SOR = bl_frags$A[1],
														 Action = "FRAGMENTED"))
			}
			# Rename new fragments
			if(nrow(new_frags) > 0){
				new_frags$id <- unlist(lapply(seq(nrow(new_frags)),function(i){paste0(new_frags$id[i],"_",i)}))
				# Store new fragment ids
				final_ids <<- c(final_ids,new_frags$id)
			}
			# Return
			return(new_frags)
		}
		return(NULL) # This shouldnt happen
	})))
}else{
	overlap_collapsed <- data.frame(start = numeric(0),
									end   = numeric(0),
									chr   = character(0),
									id    = character(0),
									Source_start = numeric(0),
									Source_end = numeric(0),
									Source_SOR = character(0),
									Action = character(0))
}

########################################
## Verbose point
if(opt$verbose) message("Generating final fragments list")

# Prepare new coordinates file after process
final_sors <- rbind(sors,overlap_collapsed[,1:4])
final_sors <- final_sors[final_sors$id %in% final_ids,]
final_sors <- final_sors[order(final_sors$chr,final_sors$start,final_sors$end),]

# Obtain stats
if(filter_cut){
	affected_sors <- length(unique(c(setdiff(sors$id,overlappings$A), # SORs without affected SORs
									overlap_collapsed$Source_SOR))) # Survived affected sors
}else{
	affected_sors <- nrow(final_sors)
}
stats <- data.frame(Stat = c("SORs original","SORs final (fragments)","SORs survived (originals fragmented and full)","Percentage original SORs survive (fragmentated included)",
							"Nucleotides SORs original","Nucleotides SORs filtered","Percentage nucleotides survive"),
					Value = c(nrow(sors), nrow(final_sors), affected_sors, affected_sors / nrow(sors),
							sum(sors$end - sors$start), sum(final_sors$end - final_sors$start), sum(final_sors$end - final_sors$start) / sum(sors$end - sors$start)))


##############################################################################
##                              UPDATE DATA                                 ##
##############################################################################

# Update network if proceeds
if(updateNet){
	########################################
	## Verbose point
	if(opt$verbose) message("Updating network")
	message("NETWOR UPDATING IS NOT IMPLEMENTED YET. Network will not be updated")
}

##############################################################################
##                              EXPORT DATA                                 ##
##############################################################################

########################################
## Verbose point
if(opt$verbose) message("Writting output")


# Export new SORs file
write.table(final_sors,file = paste0(opt$output,".txt"), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(overlap_collapsed,file = paste0(opt$output,"_filterSource.txt"), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
write.table(stats,file = paste0(opt$output,"_stats.txt"), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)

# Export overlappings without collapse
if(nrow(overlappings) > 0)
	write.table(overlappings,file = paste0(opt$output,"_overlaps.txt"), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)


# Export new network file
if(updateNet){
	
}

########################################
## Verbose point
if(opt$verbose) message("Process finished")

